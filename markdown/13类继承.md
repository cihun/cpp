# 类继承

面向对象编成的主要目的之一就是提供可重用的代码。

## 一个简单的基类

从一个类派生出另一个类的时候，原始类成为基类，继承类成为派生类。

```c++
#ifndef TABTENN0_H_
#define TABTENN0_H_
#include <string>
using std::string;

class TableTennisPlayer{
private:
    string firstname;
    string lastname;
    bool hasTable;
public:
    TableTennisPlayer (const string & fn = "none", const string & ln = "none", bool ht = false);
    void Name() const;
    bool HasTable() const {return hasTable;};  //內联函数
    void ResetTable(bool v) { hasTable = v; }; //內联函数
};
#endif
```

```c++
#include "tabtenn0.h"
#include <iostream>

TableTennisPlayer::TableTennisPlayer (const string & fn, const string & ln, bool ht) : firstname(fn), lastname(ln),  hasTable(ht){}

void TableTennisPlayer::Name() const
{
    std::cout << lastname << "," << firstname ;
}
```

对string类型的成员初始化使用成员初始化列表语法，可以减少一个string类赋值的步骤。

## 派生一个类

```c++
class RatedPlayer : public TableTennisPlayer
{
    ...
};
```

冒号指出RatedPlayer类的基类是TableTennisplayer类。

特殊的声明头表明TableTennisPlayer是一个公有基类，这被称为**公有派生**。

使用公有派生，基类的公有成员将成为派生类的公有成员。
基类的私有部分也将成为派生类的一部分，但是只能通过基类的公有和保护方法访问。

派生类可以有自己的数据与方法：

```c++
class RatedPlayer : public TableTennisPlayer
{
private:
    unsigned int rating;
public:
    RatedPlayer (unsigned int r = 0, const string & fn = "none",
                const string & ln = "none", bool ht = false);
    RatedPlayer (unsigned int r, const TableTennisPlayer & tp);
    unsigned int Rating() const { return rating; }
    void ResetRating (unsigned int r) {rating = r;}
};
```

